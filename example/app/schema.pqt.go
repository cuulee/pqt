// Code generated by pqt.
// source: cmd/appg/main.go
// DO NOT EDIT!
package main

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/go-kit/kit/log"
	"github.com/golang/protobuf/ptypes"
	"github.com/piotrkowalczuk/ntypes"
	"github.com/piotrkowalczuk/pqcomp"
	"github.com/piotrkowalczuk/pqt/pqtgo"
	"github.com/piotrkowalczuk/qtypes"
)

const (
	tableNews                     = "example.news"
	tableNewsColumnContent        = "content"
	tableNewsColumnCreatedAt      = "created_at"
	tableNewsColumnID             = "id"
	tableNewsColumnLead           = "lead"
	tableNewsColumnTitle          = "title"
	tableNewsColumnUpdatedAt      = "updated_at"
	tableNewsConstraintPrimaryKey = "example.news_id_pkey"
)

var (
	tableNewsColumns = []string{
		tableNewsColumnContent,
		tableNewsColumnCreatedAt,
		tableNewsColumnID,
		tableNewsColumnLead,
		tableNewsColumnTitle,
		tableNewsColumnUpdatedAt,
	}
)

type newsEntity struct {
	Content   string
	CreatedAt time.Time
	ID        int64
	Lead      *ntypes.String
	Title     string
	UpdatedAt *time.Time
	Comments  []*commentEntity
}

func (e *newsEntity) Prop(cn string) (interface{}, bool) {
	switch cn {
	case tableNewsColumnContent:
		return &e.Content, true
	case tableNewsColumnCreatedAt:
		return &e.CreatedAt, true
	case tableNewsColumnID:
		return &e.ID, true
	case tableNewsColumnLead:
		return &e.Lead, true
	case tableNewsColumnTitle:
		return &e.Title, true
	case tableNewsColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}
func (e *newsEntity) Props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// newsIterator is not thread safe.
type newsIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *newsIterator) Next() bool {
	return i.rows.Next()
}

func (i *newsIterator) Close() error {
	return i.rows.Close()
}

func (i *newsIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *newsIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper arround news method that makes iterator more generic.
func (i *newsIterator) Ent() (interface{}, error) {
	return i.News()
}

func (i *newsIterator) News() (*newsEntity, error) {
	var ent newsEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type newsCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	lead          *qtypes.String
	title         *qtypes.String
	updatedAt     *qtypes.Timestamp
}

func (c *newsCriteria) WriteSQL(b *bytes.Buffer, pw *pqtgo.PlaceholderWriter, args *pqtgo.Arguments) (wr int64, err error) {
	var (
		wrt   int
		wrt64 int64
		dirty bool
	)

	wbuf := bytes.NewBuffer(nil)

	if c.content != nil && c.content.Valid {
		switch c.content.Type {
		case qtypes.TextQueryType_NOT_A_TEXT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.TextQueryType_EXACT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString(" = ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.content.Value())
		case qtypes.TextQueryType_SUBSTRING:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s%%", c.content.Value()))
		case qtypes.TextQueryType_HAS_PREFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%s%%", c.content.Value()))
		case qtypes.TextQueryType_HAS_SUFFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s", c.content.Value()))
		}
	}

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return wr, err
			}
			switch c.createdAt.Type {
			case qtypes.NumericQueryType_NOT_A_NUMBER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnCreatedAt)
				if c.createdAt.Negation {
					wbuf.WriteString(" IS NOT NULL ")
				} else {
					wbuf.WriteString(" IS NULL ")
				}
			case qtypes.NumericQueryType_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnCreatedAt)
				if c.createdAt.Negation {
					wbuf.WriteString("<>")
				} else {
					wbuf.WriteString("=")
				}
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_GREATER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnCreatedAt)
				wbuf.WriteString(">")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_GREATER_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnCreatedAt)
				wbuf.WriteString(">=")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_LESS:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnCreatedAt)
				wbuf.WriteString("<")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_LESS_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnCreatedAt)
				wbuf.WriteString("<=")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if dirty {
						wbuf.WriteString(" AND ")
					}
					dirty = true

					wbuf.WriteString(tableNewsColumnCreatedAt)
					wbuf.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							wbuf.WriteString(",")
						}
						pw.WriteTo(wbuf)
						args.Add(v)
					}
					wbuf.WriteString(") ")
				}
			case qtypes.NumericQueryType_BETWEEN:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return wr, err
					}
					wbuf.WriteString(tableNewsColumnCreatedAt)
					wbuf.WriteString(" > ")
					pw.WriteTo(wbuf)
					args.Add(createdAt1)
					wbuf.WriteString(" AND ")
					wbuf.WriteString(tableNewsColumnCreatedAt)
					wbuf.WriteString(" < ")
					pw.WriteTo(wbuf)
					args.Add(createdAt2)
				}
			}
		}
	}

	if c.id != nil && c.id.Valid {
		switch c.id.Type {
		case qtypes.NumericQueryType_NOT_A_NUMBER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.NumericQueryType_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString("=")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_GREATER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_GREATER_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" < ")
			} else {
				wbuf.WriteString(" >= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_LESS:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id)
		case qtypes.NumericQueryType_LESS_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" > ")
			} else {
				wbuf.WriteString(" <= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_IN:
			if len(c.id.Values) > 0 {
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnID)
				if c.id.Negation {
					wbuf.WriteString(" NOT IN (")
				} else {
					wbuf.WriteString(" IN (")
				}
				for i, v := range c.id.Values {
					if i != 0 {
						wbuf.WriteString(",")
					}
					pw.WriteTo(wbuf)
					args.Add(v)
				}
				wbuf.WriteString(") ")
			}
		case qtypes.NumericQueryType_BETWEEN:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Values[0])
			wbuf.WriteString(" AND ")
			wbuf.WriteString(tableNewsColumnID)
			if c.id.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Values[1])
		}
	}

	if c.lead != nil && c.lead.Valid {
		switch c.lead.Type {
		case qtypes.TextQueryType_NOT_A_TEXT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnLead)
			if c.lead.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.TextQueryType_EXACT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnLead)
			if c.lead.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString(" = ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.lead.Value())
		case qtypes.TextQueryType_SUBSTRING:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnLead)
			if c.lead.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s%%", c.lead.Value()))
		case qtypes.TextQueryType_HAS_PREFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnLead)
			if c.lead.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%s%%", c.lead.Value()))
		case qtypes.TextQueryType_HAS_SUFFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnLead)
			if c.lead.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s", c.lead.Value()))
		}
	}

	if c.title != nil && c.title.Valid {
		switch c.title.Type {
		case qtypes.TextQueryType_NOT_A_TEXT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnTitle)
			if c.title.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.TextQueryType_EXACT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnTitle)
			if c.title.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString(" = ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.title.Value())
		case qtypes.TextQueryType_SUBSTRING:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnTitle)
			if c.title.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s%%", c.title.Value()))
		case qtypes.TextQueryType_HAS_PREFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnTitle)
			if c.title.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%s%%", c.title.Value()))
		case qtypes.TextQueryType_HAS_SUFFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableNewsColumnTitle)
			if c.title.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s", c.title.Value()))
		}
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return wr, err
			}
			switch c.updatedAt.Type {
			case qtypes.NumericQueryType_NOT_A_NUMBER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnUpdatedAt)
				if c.updatedAt.Negation {
					wbuf.WriteString(" IS NOT NULL ")
				} else {
					wbuf.WriteString(" IS NULL ")
				}
			case qtypes.NumericQueryType_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnUpdatedAt)
				if c.updatedAt.Negation {
					wbuf.WriteString("<>")
				} else {
					wbuf.WriteString("=")
				}
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_GREATER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnUpdatedAt)
				wbuf.WriteString(">")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_GREATER_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnUpdatedAt)
				wbuf.WriteString(">=")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_LESS:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnUpdatedAt)
				wbuf.WriteString("<")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_LESS_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableNewsColumnUpdatedAt)
				wbuf.WriteString("<=")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if dirty {
						wbuf.WriteString(" AND ")
					}
					dirty = true

					wbuf.WriteString(tableNewsColumnUpdatedAt)
					wbuf.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							wbuf.WriteString(",")
						}
						pw.WriteTo(wbuf)
						args.Add(v)
					}
					wbuf.WriteString(") ")
				}
			case qtypes.NumericQueryType_BETWEEN:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return wr, err
					}
					wbuf.WriteString(tableNewsColumnUpdatedAt)
					wbuf.WriteString(" > ")
					pw.WriteTo(wbuf)
					args.Add(updatedAt1)
					wbuf.WriteString(" AND ")
					wbuf.WriteString(tableNewsColumnUpdatedAt)
					wbuf.WriteString(" < ")
					pw.WriteTo(wbuf)
					args.Add(updatedAt2)
				}
			}
		}
	}

	if dirty {
		if wrt, err = b.WriteString(" WHERE "); err != nil {
			return
		}
		wr += int64(wrt)
		if wrt64, err = wbuf.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
	}

	if c.offset > 0 {
		b.WriteString(" OFFSET ")
		if wrt64, err = pw.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
		args.Add(c.offset)
	}
	if c.limit > 0 {
		b.WriteString(" LIMIT ")
		if wrt64, err = pw.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
		args.Add(c.limit)
	}

	return
}

type newsPatch struct {
	id        int64
	content   *ntypes.String
	createdAt *time.Time
	lead      *ntypes.String
	title     *ntypes.String
	updatedAt *time.Time
}

type newsRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func ScanNewsRows(rows *sql.Rows) ([]*newsEntity, error) {
	var (
		entities []*newsEntity
		err      error
	)
	for rows.Next() {
		var ent newsEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.Lead,
			&ent.Title,
			&ent.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *newsRepositoryBase) Count(c *newsCriteria) (int64, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT COUNT(*) FROM ")
	qbuf.WriteString(r.table)
	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return 0, err
	}
	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	err := r.db.QueryRow(qbuf.String(), args.Slice()...).Scan(&count)
	if err != nil {
		return 0, err
	}
	return count, nil
}
func (r *newsRepositoryBase) Find(c *newsCriteria) ([]*newsEntity, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT ")
	qbuf.WriteString(strings.Join(r.columns, ", "))
	qbuf.WriteString(" FROM ")
	qbuf.WriteString(r.table)

	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return nil, err
	}

	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(qbuf.String(), args.Slice()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return ScanNewsRows(rows)
}
func (r *newsRepositoryBase) FindIter(c *newsCriteria) (*newsIterator, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT ")
	qbuf.WriteString(strings.Join(r.columns, ", "))
	qbuf.WriteString(" FROM ")
	qbuf.WriteString(r.table)

	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return nil, err
	}

	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(qbuf.String(), args.Slice()...)
	if err != nil {
		return nil, err
	}

	return &newsIterator{rows: rows}, nil
}
func (r *newsRepositoryBase) FindOneByID(id int64) (*newsEntity, error) {
	var (
		query  string
		entity newsEntity
	)
	query = `SELECT content,
created_at,
id,
lead,
title,
updated_at
 FROM example.news WHERE id = $1`
	err := r.db.QueryRow(query, id).Scan(
		&entity.Content,
		&entity.CreatedAt,
		&entity.ID,
		&entity.Lead,
		&entity.Title,
		&entity.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &entity, nil
}
func (r *newsRepositoryBase) Insert(e *newsEntity) (*newsEntity, error) {
	insert := pqcomp.New(0, 6)
	insert.AddExpr(tableNewsColumnContent, "", e.Content)
	insert.AddExpr(tableNewsColumnCreatedAt, "", e.CreatedAt)
	insert.AddExpr(tableNewsColumnLead, "", e.Lead)
	insert.AddExpr(tableNewsColumnTitle, "", e.Title)
	insert.AddExpr(tableNewsColumnUpdatedAt, "", e.UpdatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString("RETURNING ")
			b.WriteString(strings.Join(r.columns, ","))
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Lead,
		&e.Title,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *newsRepositoryBase) UpdateByID(patch *newsPatch) (*newsEntity, error) {
	update := pqcomp.New(0, 6)
	update.AddExpr(tableNewsColumnID, pqcomp.Equal, patch.id)
	update.AddExpr(tableNewsColumnContent, pqcomp.Equal, patch.content)
	if patch.createdAt != nil {
		update.AddExpr(tableNewsColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableNewsColumnLead, pqcomp.Equal, patch.lead)
	update.AddExpr(tableNewsColumnTitle, pqcomp.Equal, patch.title)
	if patch.updatedAt != nil {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("main: news update failure, nothing to update")
	}
	query := "UPDATE example.news SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE id = $1 RETURNING " + strings.Join(r.columns, ", ")
	var e newsEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Lead,
		&e.Title,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}
func (r *newsRepositoryBase) DeleteByID(id int64) (int64, error) {
	query := "DELETE FROM example.news WHERE id = $1"

	res, err := r.db.Exec(query, id)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	tableComment                           = "example.comment"
	tableCommentColumnContent              = "content"
	tableCommentColumnCreatedAt            = "created_at"
	tableCommentColumnID                   = "id"
	tableCommentColumnNewsID               = "news_id"
	tableCommentColumnUpdatedAt            = "updated_at"
	tableCommentConstraintNewsIDForeignKey = "example.comment_news_id_fkey"
)

var (
	tableCommentColumns = []string{
		tableCommentColumnContent,
		tableCommentColumnCreatedAt,
		tableCommentColumnID,
		tableCommentColumnNewsID,
		tableCommentColumnUpdatedAt,
	}
)

type commentEntity struct {
	Content   string
	CreatedAt time.Time
	ID        *ntypes.Int64
	NewsID    int64
	UpdatedAt *time.Time
	News      *newsEntity
}

func (e *commentEntity) Prop(cn string) (interface{}, bool) {
	switch cn {
	case tableCommentColumnContent:
		return &e.Content, true
	case tableCommentColumnCreatedAt:
		return &e.CreatedAt, true
	case tableCommentColumnID:
		return &e.ID, true
	case tableCommentColumnNewsID:
		return &e.NewsID, true
	case tableCommentColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}
func (e *commentEntity) Props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// commentIterator is not thread safe.
type commentIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *commentIterator) Next() bool {
	return i.rows.Next()
}

func (i *commentIterator) Close() error {
	return i.rows.Close()
}

func (i *commentIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *commentIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper arround comment method that makes iterator more generic.
func (i *commentIterator) Ent() (interface{}, error) {
	return i.Comment()
}

func (i *commentIterator) Comment() (*commentEntity, error) {
	var ent commentEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type commentCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	newsID        *qtypes.Int64
	updatedAt     *qtypes.Timestamp
}

func (c *commentCriteria) WriteSQL(b *bytes.Buffer, pw *pqtgo.PlaceholderWriter, args *pqtgo.Arguments) (wr int64, err error) {
	var (
		wrt   int
		wrt64 int64
		dirty bool
	)

	wbuf := bytes.NewBuffer(nil)

	if c.content != nil && c.content.Valid {
		switch c.content.Type {
		case qtypes.TextQueryType_NOT_A_TEXT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.TextQueryType_EXACT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString(" = ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.content.Value())
		case qtypes.TextQueryType_SUBSTRING:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s%%", c.content.Value()))
		case qtypes.TextQueryType_HAS_PREFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%s%%", c.content.Value()))
		case qtypes.TextQueryType_HAS_SUFFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s", c.content.Value()))
		}
	}

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return wr, err
			}
			switch c.createdAt.Type {
			case qtypes.NumericQueryType_NOT_A_NUMBER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnCreatedAt)
				if c.createdAt.Negation {
					wbuf.WriteString(" IS NOT NULL ")
				} else {
					wbuf.WriteString(" IS NULL ")
				}
			case qtypes.NumericQueryType_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnCreatedAt)
				if c.createdAt.Negation {
					wbuf.WriteString("<>")
				} else {
					wbuf.WriteString("=")
				}
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_GREATER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnCreatedAt)
				wbuf.WriteString(">")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_GREATER_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnCreatedAt)
				wbuf.WriteString(">=")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_LESS:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnCreatedAt)
				wbuf.WriteString("<")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_LESS_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnCreatedAt)
				wbuf.WriteString("<=")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if dirty {
						wbuf.WriteString(" AND ")
					}
					dirty = true

					wbuf.WriteString(tableCommentColumnCreatedAt)
					wbuf.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							wbuf.WriteString(",")
						}
						pw.WriteTo(wbuf)
						args.Add(v)
					}
					wbuf.WriteString(") ")
				}
			case qtypes.NumericQueryType_BETWEEN:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return wr, err
					}
					wbuf.WriteString(tableCommentColumnCreatedAt)
					wbuf.WriteString(" > ")
					pw.WriteTo(wbuf)
					args.Add(createdAt1)
					wbuf.WriteString(" AND ")
					wbuf.WriteString(tableCommentColumnCreatedAt)
					wbuf.WriteString(" < ")
					pw.WriteTo(wbuf)
					args.Add(createdAt2)
				}
			}
		}
	}

	if c.id != nil && c.id.Valid {
		switch c.id.Type {
		case qtypes.NumericQueryType_NOT_A_NUMBER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.NumericQueryType_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString("=")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_GREATER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_GREATER_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" < ")
			} else {
				wbuf.WriteString(" >= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_LESS:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id)
		case qtypes.NumericQueryType_LESS_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" > ")
			} else {
				wbuf.WriteString(" <= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_IN:
			if len(c.id.Values) > 0 {
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnID)
				if c.id.Negation {
					wbuf.WriteString(" NOT IN (")
				} else {
					wbuf.WriteString(" IN (")
				}
				for i, v := range c.id.Values {
					if i != 0 {
						wbuf.WriteString(",")
					}
					pw.WriteTo(wbuf)
					args.Add(v)
				}
				wbuf.WriteString(") ")
			}
		case qtypes.NumericQueryType_BETWEEN:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Values[0])
			wbuf.WriteString(" AND ")
			wbuf.WriteString(tableCommentColumnID)
			if c.id.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Values[1])
		}
	}

	if c.newsID != nil && c.newsID.Valid {
		switch c.newsID.Type {
		case qtypes.NumericQueryType_NOT_A_NUMBER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.NumericQueryType_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString("=")
			}
			pw.WriteTo(wbuf)
			args.Add(c.newsID.Value())
		case qtypes.NumericQueryType_GREATER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.newsID.Value())
		case qtypes.NumericQueryType_GREATER_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" < ")
			} else {
				wbuf.WriteString(" >= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.newsID.Value())
		case qtypes.NumericQueryType_LESS:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.newsID)
		case qtypes.NumericQueryType_LESS_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" > ")
			} else {
				wbuf.WriteString(" <= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.newsID.Value())
		case qtypes.NumericQueryType_IN:
			if len(c.newsID.Values) > 0 {
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnNewsID)
				if c.newsID.Negation {
					wbuf.WriteString(" NOT IN (")
				} else {
					wbuf.WriteString(" IN (")
				}
				for i, v := range c.newsID.Values {
					if i != 0 {
						wbuf.WriteString(",")
					}
					pw.WriteTo(wbuf)
					args.Add(v)
				}
				wbuf.WriteString(") ")
			}
		case qtypes.NumericQueryType_BETWEEN:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.newsID.Values[0])
			wbuf.WriteString(" AND ")
			wbuf.WriteString(tableCommentColumnNewsID)
			if c.newsID.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.newsID.Values[1])
		}
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return wr, err
			}
			switch c.updatedAt.Type {
			case qtypes.NumericQueryType_NOT_A_NUMBER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnUpdatedAt)
				if c.updatedAt.Negation {
					wbuf.WriteString(" IS NOT NULL ")
				} else {
					wbuf.WriteString(" IS NULL ")
				}
			case qtypes.NumericQueryType_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnUpdatedAt)
				if c.updatedAt.Negation {
					wbuf.WriteString("<>")
				} else {
					wbuf.WriteString("=")
				}
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_GREATER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnUpdatedAt)
				wbuf.WriteString(">")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_GREATER_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnUpdatedAt)
				wbuf.WriteString(">=")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_LESS:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnUpdatedAt)
				wbuf.WriteString("<")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_LESS_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCommentColumnUpdatedAt)
				wbuf.WriteString("<=")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if dirty {
						wbuf.WriteString(" AND ")
					}
					dirty = true

					wbuf.WriteString(tableCommentColumnUpdatedAt)
					wbuf.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							wbuf.WriteString(",")
						}
						pw.WriteTo(wbuf)
						args.Add(v)
					}
					wbuf.WriteString(") ")
				}
			case qtypes.NumericQueryType_BETWEEN:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return wr, err
					}
					wbuf.WriteString(tableCommentColumnUpdatedAt)
					wbuf.WriteString(" > ")
					pw.WriteTo(wbuf)
					args.Add(updatedAt1)
					wbuf.WriteString(" AND ")
					wbuf.WriteString(tableCommentColumnUpdatedAt)
					wbuf.WriteString(" < ")
					pw.WriteTo(wbuf)
					args.Add(updatedAt2)
				}
			}
		}
	}

	if dirty {
		if wrt, err = b.WriteString(" WHERE "); err != nil {
			return
		}
		wr += int64(wrt)
		if wrt64, err = wbuf.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
	}

	if c.offset > 0 {
		b.WriteString(" OFFSET ")
		if wrt64, err = pw.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
		args.Add(c.offset)
	}
	if c.limit > 0 {
		b.WriteString(" LIMIT ")
		if wrt64, err = pw.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
		args.Add(c.limit)
	}

	return
}

type commentRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func ScanCommentRows(rows *sql.Rows) ([]*commentEntity, error) {
	var (
		entities []*commentEntity
		err      error
	)
	for rows.Next() {
		var ent commentEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.NewsID,
			&ent.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *commentRepositoryBase) Count(c *commentCriteria) (int64, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT COUNT(*) FROM ")
	qbuf.WriteString(r.table)
	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return 0, err
	}
	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	err := r.db.QueryRow(qbuf.String(), args.Slice()...).Scan(&count)
	if err != nil {
		return 0, err
	}
	return count, nil
}
func (r *commentRepositoryBase) Find(c *commentCriteria) ([]*commentEntity, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT ")
	qbuf.WriteString(strings.Join(r.columns, ", "))
	qbuf.WriteString(" FROM ")
	qbuf.WriteString(r.table)

	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return nil, err
	}

	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(qbuf.String(), args.Slice()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return ScanCommentRows(rows)
}
func (r *commentRepositoryBase) FindIter(c *commentCriteria) (*commentIterator, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT ")
	qbuf.WriteString(strings.Join(r.columns, ", "))
	qbuf.WriteString(" FROM ")
	qbuf.WriteString(r.table)

	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return nil, err
	}

	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(qbuf.String(), args.Slice()...)
	if err != nil {
		return nil, err
	}

	return &commentIterator{rows: rows}, nil
}
func (r *commentRepositoryBase) Insert(e *commentEntity) (*commentEntity, error) {
	insert := pqcomp.New(0, 5)
	insert.AddExpr(tableCommentColumnContent, "", e.Content)
	insert.AddExpr(tableCommentColumnCreatedAt, "", e.CreatedAt)
	insert.AddExpr(tableCommentColumnNewsID, "", e.NewsID)
	insert.AddExpr(tableCommentColumnUpdatedAt, "", e.UpdatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString("RETURNING ")
			b.WriteString(strings.Join(r.columns, ","))
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.NewsID,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}

const (
	tableCategory                             = "example.category"
	tableCategoryColumnContent                = "content"
	tableCategoryColumnCreatedAt              = "created_at"
	tableCategoryColumnID                     = "id"
	tableCategoryColumnName                   = "name"
	tableCategoryColumnParentID               = "parent_id"
	tableCategoryColumnUpdatedAt              = "updated_at"
	tableCategoryConstraintPrimaryKey         = "example.category_id_pkey"
	tableCategoryConstraintParentIDForeignKey = "example.category_parent_id_fkey"
)

var (
	tableCategoryColumns = []string{
		tableCategoryColumnContent,
		tableCategoryColumnCreatedAt,
		tableCategoryColumnID,
		tableCategoryColumnName,
		tableCategoryColumnParentID,
		tableCategoryColumnUpdatedAt,
	}
)

type categoryEntity struct {
	Content        string
	CreatedAt      time.Time
	ID             int64
	Name           string
	ParentID       *ntypes.Int64
	UpdatedAt      *time.Time
	ChildCategory  []*categoryEntity
	ParentCategory *categoryEntity
}

func (e *categoryEntity) Prop(cn string) (interface{}, bool) {
	switch cn {
	case tableCategoryColumnContent:
		return &e.Content, true
	case tableCategoryColumnCreatedAt:
		return &e.CreatedAt, true
	case tableCategoryColumnID:
		return &e.ID, true
	case tableCategoryColumnName:
		return &e.Name, true
	case tableCategoryColumnParentID:
		return &e.ParentID, true
	case tableCategoryColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}
func (e *categoryEntity) Props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// categoryIterator is not thread safe.
type categoryIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *categoryIterator) Next() bool {
	return i.rows.Next()
}

func (i *categoryIterator) Close() error {
	return i.rows.Close()
}

func (i *categoryIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *categoryIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper arround category method that makes iterator more generic.
func (i *categoryIterator) Ent() (interface{}, error) {
	return i.Category()
}

func (i *categoryIterator) Category() (*categoryEntity, error) {
	var ent categoryEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type categoryCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	name          *qtypes.String
	parentID      *qtypes.Int64
	updatedAt     *qtypes.Timestamp
}

func (c *categoryCriteria) WriteSQL(b *bytes.Buffer, pw *pqtgo.PlaceholderWriter, args *pqtgo.Arguments) (wr int64, err error) {
	var (
		wrt   int
		wrt64 int64
		dirty bool
	)

	wbuf := bytes.NewBuffer(nil)

	if c.content != nil && c.content.Valid {
		switch c.content.Type {
		case qtypes.TextQueryType_NOT_A_TEXT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.TextQueryType_EXACT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString(" = ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.content.Value())
		case qtypes.TextQueryType_SUBSTRING:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s%%", c.content.Value()))
		case qtypes.TextQueryType_HAS_PREFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%s%%", c.content.Value()))
		case qtypes.TextQueryType_HAS_SUFFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnContent)
			if c.content.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s", c.content.Value()))
		}
	}

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return wr, err
			}
			switch c.createdAt.Type {
			case qtypes.NumericQueryType_NOT_A_NUMBER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnCreatedAt)
				if c.createdAt.Negation {
					wbuf.WriteString(" IS NOT NULL ")
				} else {
					wbuf.WriteString(" IS NULL ")
				}
			case qtypes.NumericQueryType_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnCreatedAt)
				if c.createdAt.Negation {
					wbuf.WriteString("<>")
				} else {
					wbuf.WriteString("=")
				}
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_GREATER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnCreatedAt)
				wbuf.WriteString(">")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_GREATER_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnCreatedAt)
				wbuf.WriteString(">=")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_LESS:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnCreatedAt)
				wbuf.WriteString("<")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_LESS_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnCreatedAt)
				wbuf.WriteString("<=")
				pw.WriteTo(wbuf)
				args.Add(c.createdAt.Value())
			case qtypes.NumericQueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if dirty {
						wbuf.WriteString(" AND ")
					}
					dirty = true

					wbuf.WriteString(tableCategoryColumnCreatedAt)
					wbuf.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							wbuf.WriteString(",")
						}
						pw.WriteTo(wbuf)
						args.Add(v)
					}
					wbuf.WriteString(") ")
				}
			case qtypes.NumericQueryType_BETWEEN:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return wr, err
					}
					wbuf.WriteString(tableCategoryColumnCreatedAt)
					wbuf.WriteString(" > ")
					pw.WriteTo(wbuf)
					args.Add(createdAt1)
					wbuf.WriteString(" AND ")
					wbuf.WriteString(tableCategoryColumnCreatedAt)
					wbuf.WriteString(" < ")
					pw.WriteTo(wbuf)
					args.Add(createdAt2)
				}
			}
		}
	}

	if c.id != nil && c.id.Valid {
		switch c.id.Type {
		case qtypes.NumericQueryType_NOT_A_NUMBER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.NumericQueryType_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString("=")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_GREATER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_GREATER_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" < ")
			} else {
				wbuf.WriteString(" >= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_LESS:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id)
		case qtypes.NumericQueryType_LESS_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" > ")
			} else {
				wbuf.WriteString(" <= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Value())
		case qtypes.NumericQueryType_IN:
			if len(c.id.Values) > 0 {
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnID)
				if c.id.Negation {
					wbuf.WriteString(" NOT IN (")
				} else {
					wbuf.WriteString(" IN (")
				}
				for i, v := range c.id.Values {
					if i != 0 {
						wbuf.WriteString(",")
					}
					pw.WriteTo(wbuf)
					args.Add(v)
				}
				wbuf.WriteString(") ")
			}
		case qtypes.NumericQueryType_BETWEEN:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Values[0])
			wbuf.WriteString(" AND ")
			wbuf.WriteString(tableCategoryColumnID)
			if c.id.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.id.Values[1])
		}
	}

	if c.name != nil && c.name.Valid {
		switch c.name.Type {
		case qtypes.TextQueryType_NOT_A_TEXT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnName)
			if c.name.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.TextQueryType_EXACT:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnName)
			if c.name.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString(" = ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.name.Value())
		case qtypes.TextQueryType_SUBSTRING:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnName)
			if c.name.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s%%", c.name.Value()))
		case qtypes.TextQueryType_HAS_PREFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnName)
			if c.name.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%s%%", c.name.Value()))
		case qtypes.TextQueryType_HAS_SUFFIX:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnName)
			if c.name.Negation {
				wbuf.WriteString(" NOT LIKE ")
			} else {
				wbuf.WriteString(" LIKE ")
			}
			pw.WriteTo(wbuf)
			args.Add(fmt.Sprintf("%%%s", c.name.Value()))
		}
	}

	if c.parentID != nil && c.parentID.Valid {
		switch c.parentID.Type {
		case qtypes.NumericQueryType_NOT_A_NUMBER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" IS NOT NULL ")
			} else {
				wbuf.WriteString(" IS NULL ")
			}
		case qtypes.NumericQueryType_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" <> ")
			} else {
				wbuf.WriteString("=")
			}
			pw.WriteTo(wbuf)
			args.Add(c.parentID.Value())
		case qtypes.NumericQueryType_GREATER:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.parentID.Value())
		case qtypes.NumericQueryType_GREATER_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" < ")
			} else {
				wbuf.WriteString(" >= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.parentID.Value())
		case qtypes.NumericQueryType_LESS:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.parentID)
		case qtypes.NumericQueryType_LESS_EQUAL:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" > ")
			} else {
				wbuf.WriteString(" <= ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.parentID.Value())
		case qtypes.NumericQueryType_IN:
			if len(c.parentID.Values) > 0 {
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnParentID)
				if c.parentID.Negation {
					wbuf.WriteString(" NOT IN (")
				} else {
					wbuf.WriteString(" IN (")
				}
				for i, v := range c.parentID.Values {
					if i != 0 {
						wbuf.WriteString(",")
					}
					pw.WriteTo(wbuf)
					args.Add(v)
				}
				wbuf.WriteString(") ")
			}
		case qtypes.NumericQueryType_BETWEEN:
			if dirty {
				wbuf.WriteString(" AND ")
			}
			dirty = true

			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" <= ")
			} else {
				wbuf.WriteString(" > ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.parentID.Values[0])
			wbuf.WriteString(" AND ")
			wbuf.WriteString(tableCategoryColumnParentID)
			if c.parentID.Negation {
				wbuf.WriteString(" >= ")
			} else {
				wbuf.WriteString(" < ")
			}
			pw.WriteTo(wbuf)
			args.Add(c.parentID.Values[1])
		}
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return wr, err
			}
			switch c.updatedAt.Type {
			case qtypes.NumericQueryType_NOT_A_NUMBER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnUpdatedAt)
				if c.updatedAt.Negation {
					wbuf.WriteString(" IS NOT NULL ")
				} else {
					wbuf.WriteString(" IS NULL ")
				}
			case qtypes.NumericQueryType_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnUpdatedAt)
				if c.updatedAt.Negation {
					wbuf.WriteString("<>")
				} else {
					wbuf.WriteString("=")
				}
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_GREATER:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnUpdatedAt)
				wbuf.WriteString(">")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_GREATER_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnUpdatedAt)
				wbuf.WriteString(">=")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_LESS:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnUpdatedAt)
				wbuf.WriteString("<")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_LESS_EQUAL:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				wbuf.WriteString(tableCategoryColumnUpdatedAt)
				wbuf.WriteString("<=")
				pw.WriteTo(wbuf)
				args.Add(c.updatedAt.Value())
			case qtypes.NumericQueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if dirty {
						wbuf.WriteString(" AND ")
					}
					dirty = true

					wbuf.WriteString(tableCategoryColumnUpdatedAt)
					wbuf.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							wbuf.WriteString(",")
						}
						pw.WriteTo(wbuf)
						args.Add(v)
					}
					wbuf.WriteString(") ")
				}
			case qtypes.NumericQueryType_BETWEEN:
				if dirty {
					wbuf.WriteString(" AND ")
				}
				dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return wr, err
					}
					wbuf.WriteString(tableCategoryColumnUpdatedAt)
					wbuf.WriteString(" > ")
					pw.WriteTo(wbuf)
					args.Add(updatedAt1)
					wbuf.WriteString(" AND ")
					wbuf.WriteString(tableCategoryColumnUpdatedAt)
					wbuf.WriteString(" < ")
					pw.WriteTo(wbuf)
					args.Add(updatedAt2)
				}
			}
		}
	}

	if dirty {
		if wrt, err = b.WriteString(" WHERE "); err != nil {
			return
		}
		wr += int64(wrt)
		if wrt64, err = wbuf.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
	}

	if c.offset > 0 {
		b.WriteString(" OFFSET ")
		if wrt64, err = pw.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
		args.Add(c.offset)
	}
	if c.limit > 0 {
		b.WriteString(" LIMIT ")
		if wrt64, err = pw.WriteTo(b); err != nil {
			return
		}
		wr += wrt64
		args.Add(c.limit)
	}

	return
}

type categoryPatch struct {
	id        int64
	content   *ntypes.String
	createdAt *time.Time
	name      *ntypes.String
	parentID  *ntypes.Int64
	updatedAt *time.Time
}

type categoryRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func ScanCategoryRows(rows *sql.Rows) ([]*categoryEntity, error) {
	var (
		entities []*categoryEntity
		err      error
	)
	for rows.Next() {
		var ent categoryEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.Name,
			&ent.ParentID,
			&ent.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *categoryRepositoryBase) Count(c *categoryCriteria) (int64, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT COUNT(*) FROM ")
	qbuf.WriteString(r.table)
	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return 0, err
	}
	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	err := r.db.QueryRow(qbuf.String(), args.Slice()...).Scan(&count)
	if err != nil {
		return 0, err
	}
	return count, nil
}
func (r *categoryRepositoryBase) Find(c *categoryCriteria) ([]*categoryEntity, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT ")
	qbuf.WriteString(strings.Join(r.columns, ", "))
	qbuf.WriteString(" FROM ")
	qbuf.WriteString(r.table)

	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return nil, err
	}

	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(qbuf.String(), args.Slice()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return ScanCategoryRows(rows)
}
func (r *categoryRepositoryBase) FindIter(c *categoryCriteria) (*categoryIterator, error) {

	qbuf := bytes.NewBuffer(nil)
	qbuf.WriteString("SELECT ")
	qbuf.WriteString(strings.Join(r.columns, ", "))
	qbuf.WriteString(" FROM ")
	qbuf.WriteString(r.table)

	pw := pqtgo.NewPlaceholderWriter()
	args := pqtgo.NewArguments(0)

	if _, err := c.WriteSQL(qbuf, pw, args); err != nil {
		return nil, err
	}

	if r.dbg {
		if err := r.log.Log("msg", qbuf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(qbuf.String(), args.Slice()...)
	if err != nil {
		return nil, err
	}

	return &categoryIterator{rows: rows}, nil
}
func (r *categoryRepositoryBase) FindOneByID(id int64) (*categoryEntity, error) {
	var (
		query  string
		entity categoryEntity
	)
	query = `SELECT content,
created_at,
id,
name,
parent_id,
updated_at
 FROM example.category WHERE id = $1`
	err := r.db.QueryRow(query, id).Scan(
		&entity.Content,
		&entity.CreatedAt,
		&entity.ID,
		&entity.Name,
		&entity.ParentID,
		&entity.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &entity, nil
}
func (r *categoryRepositoryBase) Insert(e *categoryEntity) (*categoryEntity, error) {
	insert := pqcomp.New(0, 6)
	insert.AddExpr(tableCategoryColumnContent, "", e.Content)
	insert.AddExpr(tableCategoryColumnCreatedAt, "", e.CreatedAt)
	insert.AddExpr(tableCategoryColumnName, "", e.Name)
	insert.AddExpr(tableCategoryColumnParentID, "", e.ParentID)
	insert.AddExpr(tableCategoryColumnUpdatedAt, "", e.UpdatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString("RETURNING ")
			b.WriteString(strings.Join(r.columns, ","))
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Name,
		&e.ParentID,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *categoryRepositoryBase) UpdateByID(patch *categoryPatch) (*categoryEntity, error) {
	update := pqcomp.New(0, 6)
	update.AddExpr(tableCategoryColumnID, pqcomp.Equal, patch.id)
	update.AddExpr(tableCategoryColumnContent, pqcomp.Equal, patch.content)
	if patch.createdAt != nil {
		update.AddExpr(tableCategoryColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableCategoryColumnName, pqcomp.Equal, patch.name)
	update.AddExpr(tableCategoryColumnParentID, pqcomp.Equal, patch.parentID)
	if patch.updatedAt != nil {
		update.AddExpr(tableCategoryColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableCategoryColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("main: category update failure, nothing to update")
	}
	query := "UPDATE example.category SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE id = $1 RETURNING " + strings.Join(r.columns, ", ")
	var e categoryEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Name,
		&e.ParentID,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}
func (r *categoryRepositoryBase) DeleteByID(id int64) (int64, error) {
	query := "DELETE FROM example.category WHERE id = $1"

	res, err := r.db.Exec(query, id)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const SQL = `
-- do not modify, generated by pqt

CREATE SCHEMA IF NOT EXISTS example; 

CREATE TABLE IF NOT EXISTS example.news (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	lead TEXT,
	title TEXT NOT NULL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.news_id_pkey" PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS example.comment (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	news_id BIGINT NOT NULL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.comment_news_id_fkey" FOREIGN KEY (news_id) REFERENCES example.news (id)
);

CREATE TABLE IF NOT EXISTS example.category (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	name TEXT NOT NULL,
	parent_id BIGINT,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.category_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.category_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES example.category (id)
);

`
