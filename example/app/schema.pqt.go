// Code generated by pqt.
// source: cmd/appg/main.go
// DO NOT EDIT!
package main

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/go-kit/kit/log"
	"github.com/golang/protobuf/ptypes"
	"github.com/piotrkowalczuk/ntypes"
	"github.com/piotrkowalczuk/pqcomp"
	"github.com/piotrkowalczuk/pqt/pqtgo"
	"github.com/piotrkowalczuk/qtypes"
)

const (
	tableNews                      = "example.news"
	tableNewsColumnContent         = "content"
	tableNewsColumnCreatedAt       = "created_at"
	tableNewsColumnID              = "id"
	tableNewsColumnLead            = "lead"
	tableNewsColumnTitle           = "title"
	tableNewsColumnUpdatedAt       = "updated_at"
	tableNewsConstraintPrimaryKey  = "example.news_id_pkey"
	tableNewsConstraintTitleUnique = "example.news_title_key"
)

var (
	tableNewsColumns = []string{
		tableNewsColumnContent,
		tableNewsColumnCreatedAt,
		tableNewsColumnID,
		tableNewsColumnLead,
		tableNewsColumnTitle,
		tableNewsColumnUpdatedAt,
	}
)

type newsEntity struct {
	Content   string
	CreatedAt time.Time
	ID        int64
	Lead      *ntypes.String
	Title     string
	UpdatedAt *time.Time
	Comments  []*commentEntity
}

func (e *newsEntity) Prop(cn string) (interface{}, bool) {
	switch cn {
	case tableNewsColumnContent:
		return &e.Content, true
	case tableNewsColumnCreatedAt:
		return &e.CreatedAt, true
	case tableNewsColumnID:
		return &e.ID, true
	case tableNewsColumnLead:
		return &e.Lead, true
	case tableNewsColumnTitle:
		return &e.Title, true
	case tableNewsColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}
func (e *newsEntity) Props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// newsIterator is not thread safe.
type newsIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *newsIterator) Next() bool {
	return i.rows.Next()
}

func (i *newsIterator) Close() error {
	return i.rows.Close()
}

func (i *newsIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *newsIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper arround news method that makes iterator more generic.
func (i *newsIterator) Ent() (interface{}, error) {
	return i.News()
}

func (i *newsIterator) News() (*newsEntity, error) {
	var ent newsEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type newsCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	lead          *qtypes.String
	title         *qtypes.String
	updatedAt     *qtypes.Timestamp
}

func (c *newsCriteria) WriteComposition(sel string, com *pqtgo.Composer, opt *pqtgo.CompositionOpts) (err error) {
	if _, err = com.WriteString(" WHERE "); err != nil {
		return
	}

	if c.content != nil && c.content.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	pqtgo.WriteCompositionQueryString(c.content, tableNewsColumnContent, com, pqtgo.And)

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return err
			}
			switch c.createdAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnCreatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableNewsColumnCreatedAt)
					com.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							com.WriteString(",")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableNewsColumnCreatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(createdAt1)
					com.WriteString(" AND ")
					com.WriteString(tableNewsColumnCreatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(createdAt2)
				}
			}
		}
	}

	if c.id != nil && c.id.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	if err = pqtgo.WriteCompositionQueryInt64(c.id, tableNewsColumnID, com, pqtgo.And); err != nil {
		return
	}

	if c.lead != nil && c.lead.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	pqtgo.WriteCompositionQueryString(c.lead, tableNewsColumnLead, com, pqtgo.And)

	if c.title != nil && c.title.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	pqtgo.WriteCompositionQueryString(c.title, tableNewsColumnTitle, com, pqtgo.And)

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return err
			}
			switch c.updatedAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableNewsColumnUpdatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableNewsColumnUpdatedAt)
					com.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							com.WriteString(",")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableNewsColumnUpdatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(updatedAt1)
					com.WriteString(" AND ")
					com.WriteString(tableNewsColumnUpdatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(updatedAt2)
				}
			}
		}
	}

	if !com.Dirty {
		com.ResetBuf()
	}
	if c.offset > 0 {
		if _, err = com.WriteString(" OFFSET "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.offset)
	}
	if c.limit > 0 {
		if _, err = com.WriteString(" LIMIT "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.limit)
	}
	com.Dirty = false

	return
}

type newsPatch struct {
	content   *ntypes.String
	createdAt *time.Time
	lead      *ntypes.String
	title     *ntypes.String
	updatedAt *time.Time
}

type newsRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func ScanNewsRows(rows *sql.Rows) ([]*newsEntity, error) {
	var (
		entities []*newsEntity
		err      error
	)
	for rows.Next() {
		var ent newsEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.Lead,
			&ent.Title,
			&ent.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *newsRepositoryBase) Count(c *newsCriteria) (int64, error) {

	com := pqtgo.NewComposer(6)
	buf := bytes.NewBufferString("SELECT COUNT(*) FROM ")
	buf.WriteString(r.table)

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return 0, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	if err := r.db.QueryRow(buf.String(), com.Args()...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *newsRepositoryBase) Find(c *newsCriteria) ([]*newsEntity, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return ScanNewsRows(rows)
}
func (r *newsRepositoryBase) FindIter(c *newsCriteria) (*newsIterator, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	return &newsIterator{rows: rows}, nil
}
func (r *newsRepositoryBase) FindOneByID(id int64) (*newsEntity, error) {
	var (
		query  string
		entity newsEntity
	)
	query = `SELECT content,
created_at,
id,
lead,
title,
updated_at
 FROM example.news WHERE id = $1`
	err := r.db.QueryRow(query, id).Scan(
		&entity.Content,
		&entity.CreatedAt,
		&entity.ID,
		&entity.Lead,
		&entity.Title,
		&entity.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &entity, nil
}
func (r *newsRepositoryBase) Insert(e *newsEntity) (*newsEntity, error) {
	insert := pqcomp.New(0, 6)
	insert.AddExpr(tableNewsColumnContent, "", e.Content)
	insert.AddExpr(tableNewsColumnCreatedAt, "", e.CreatedAt)
	insert.AddExpr(tableNewsColumnLead, "", e.Lead)
	insert.AddExpr(tableNewsColumnTitle, "", e.Title)
	insert.AddExpr(tableNewsColumnUpdatedAt, "", e.UpdatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString("RETURNING ")
			b.WriteString(strings.Join(r.columns, ","))
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Lead,
		&e.Title,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *newsRepositoryBase) UpdateOneByID(id int64, patch *newsPatch) (*newsEntity, error) {
	update := pqcomp.New(0, 6)
	update.AddExpr(tableNewsColumnID, pqcomp.Equal, id)
	update.AddExpr(tableNewsColumnContent, pqcomp.Equal, patch.content)
	if patch.createdAt != nil {
		update.AddExpr(tableNewsColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableNewsColumnLead, pqcomp.Equal, patch.lead)
	update.AddExpr(tableNewsColumnTitle, pqcomp.Equal, patch.title)
	if patch.updatedAt != nil {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableNewsColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("news update failure, nothing to update")
	}
	query := "UPDATE example.news SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE id = $1 RETURNING " + strings.Join(r.columns, ", ")
	var e newsEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Lead,
		&e.Title,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}
func (r *newsRepositoryBase) DeleteOneByID(id int64) (int64, error) {
	query := "DELETE FROM example.news WHERE id = $1"

	res, err := r.db.Exec(query, id)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	tableComment                              = "example.comment"
	tableCommentColumnContent                 = "content"
	tableCommentColumnCreatedAt               = "created_at"
	tableCommentColumnID                      = "id"
	tableCommentColumnNewsID                  = "news_id"
	tableCommentColumnNewsTitle               = "news_title"
	tableCommentColumnUpdatedAt               = "updated_at"
	tableCommentConstraintNewsIDForeignKey    = "example.comment_news_id_fkey"
	tableCommentConstraintNewsTitleForeignKey = "example.comment_news_title_fkey"
)

var (
	tableCommentColumns = []string{
		tableCommentColumnContent,
		tableCommentColumnCreatedAt,
		tableCommentColumnID,
		tableCommentColumnNewsID,
		tableCommentColumnNewsTitle,
		tableCommentColumnUpdatedAt,
	}
)

type commentEntity struct {
	Content   string
	CreatedAt time.Time
	ID        *ntypes.Int64
	NewsID    int64
	NewsTitle string
	UpdatedAt *time.Time
	News      *newsEntity
}

func (e *commentEntity) Prop(cn string) (interface{}, bool) {
	switch cn {
	case tableCommentColumnContent:
		return &e.Content, true
	case tableCommentColumnCreatedAt:
		return &e.CreatedAt, true
	case tableCommentColumnID:
		return &e.ID, true
	case tableCommentColumnNewsID:
		return &e.NewsID, true
	case tableCommentColumnNewsTitle:
		return &e.NewsTitle, true
	case tableCommentColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}
func (e *commentEntity) Props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// commentIterator is not thread safe.
type commentIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *commentIterator) Next() bool {
	return i.rows.Next()
}

func (i *commentIterator) Close() error {
	return i.rows.Close()
}

func (i *commentIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *commentIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper arround comment method that makes iterator more generic.
func (i *commentIterator) Ent() (interface{}, error) {
	return i.Comment()
}

func (i *commentIterator) Comment() (*commentEntity, error) {
	var ent commentEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type commentCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	newsID        *qtypes.Int64
	newsTitle     *qtypes.String
	updatedAt     *qtypes.Timestamp
}

func (c *commentCriteria) WriteComposition(sel string, com *pqtgo.Composer, opt *pqtgo.CompositionOpts) (err error) {
	if _, err = com.WriteString(" WHERE "); err != nil {
		return
	}

	if c.content != nil && c.content.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	pqtgo.WriteCompositionQueryString(c.content, tableCommentColumnContent, com, pqtgo.And)

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return err
			}
			switch c.createdAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnCreatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCommentColumnCreatedAt)
					com.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							com.WriteString(",")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCommentColumnCreatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(createdAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCommentColumnCreatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(createdAt2)
				}
			}
		}
	}

	if c.id != nil && c.id.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	if err = pqtgo.WriteCompositionQueryInt64(c.id, tableCommentColumnID, com, pqtgo.And); err != nil {
		return
	}

	if c.newsID != nil && c.newsID.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	if err = pqtgo.WriteCompositionQueryInt64(c.newsID, tableCommentColumnNewsID, com, pqtgo.And); err != nil {
		return
	}

	if c.newsTitle != nil && c.newsTitle.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	pqtgo.WriteCompositionQueryString(c.newsTitle, tableCommentColumnNewsTitle, com, pqtgo.And)

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return err
			}
			switch c.updatedAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCommentColumnUpdatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCommentColumnUpdatedAt)
					com.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							com.WriteString(",")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCommentColumnUpdatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(updatedAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCommentColumnUpdatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(updatedAt2)
				}
			}
		}
	}

	if !com.Dirty {
		com.ResetBuf()
	}
	if c.offset > 0 {
		if _, err = com.WriteString(" OFFSET "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.offset)
	}
	if c.limit > 0 {
		if _, err = com.WriteString(" LIMIT "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.limit)
	}
	com.Dirty = false

	return
}

type commentRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func ScanCommentRows(rows *sql.Rows) ([]*commentEntity, error) {
	var (
		entities []*commentEntity
		err      error
	)
	for rows.Next() {
		var ent commentEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.NewsID,
			&ent.NewsTitle,
			&ent.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *commentRepositoryBase) Count(c *commentCriteria) (int64, error) {

	com := pqtgo.NewComposer(6)
	buf := bytes.NewBufferString("SELECT COUNT(*) FROM ")
	buf.WriteString(r.table)

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return 0, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	if err := r.db.QueryRow(buf.String(), com.Args()...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *commentRepositoryBase) Find(c *commentCriteria) ([]*commentEntity, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return ScanCommentRows(rows)
}
func (r *commentRepositoryBase) FindIter(c *commentCriteria) (*commentIterator, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	return &commentIterator{rows: rows}, nil
}
func (r *commentRepositoryBase) Insert(e *commentEntity) (*commentEntity, error) {
	insert := pqcomp.New(0, 6)
	insert.AddExpr(tableCommentColumnContent, "", e.Content)
	insert.AddExpr(tableCommentColumnCreatedAt, "", e.CreatedAt)
	insert.AddExpr(tableCommentColumnNewsID, "", e.NewsID)
	insert.AddExpr(tableCommentColumnNewsTitle, "", e.NewsTitle)
	insert.AddExpr(tableCommentColumnUpdatedAt, "", e.UpdatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString("RETURNING ")
			b.WriteString(strings.Join(r.columns, ","))
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.NewsID,
		&e.NewsTitle,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}

const (
	tableCategory                             = "example.category"
	tableCategoryColumnContent                = "content"
	tableCategoryColumnCreatedAt              = "created_at"
	tableCategoryColumnID                     = "id"
	tableCategoryColumnName                   = "name"
	tableCategoryColumnParentID               = "parent_id"
	tableCategoryColumnUpdatedAt              = "updated_at"
	tableCategoryConstraintPrimaryKey         = "example.category_id_pkey"
	tableCategoryConstraintParentIDForeignKey = "example.category_parent_id_fkey"
)

var (
	tableCategoryColumns = []string{
		tableCategoryColumnContent,
		tableCategoryColumnCreatedAt,
		tableCategoryColumnID,
		tableCategoryColumnName,
		tableCategoryColumnParentID,
		tableCategoryColumnUpdatedAt,
	}
)

type categoryEntity struct {
	Content        string
	CreatedAt      time.Time
	ID             int64
	Name           string
	ParentID       *ntypes.Int64
	UpdatedAt      *time.Time
	ChildCategory  []*categoryEntity
	ParentCategory *categoryEntity
}

func (e *categoryEntity) Prop(cn string) (interface{}, bool) {
	switch cn {
	case tableCategoryColumnContent:
		return &e.Content, true
	case tableCategoryColumnCreatedAt:
		return &e.CreatedAt, true
	case tableCategoryColumnID:
		return &e.ID, true
	case tableCategoryColumnName:
		return &e.Name, true
	case tableCategoryColumnParentID:
		return &e.ParentID, true
	case tableCategoryColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}
func (e *categoryEntity) Props(cns ...string) ([]interface{}, error) {

	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// categoryIterator is not thread safe.
type categoryIterator struct {
	rows *sql.Rows
	cols []string
}

func (i *categoryIterator) Next() bool {
	return i.rows.Next()
}

func (i *categoryIterator) Close() error {
	return i.rows.Close()
}

func (i *categoryIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache outpu inside iterator.
func (i *categoryIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper arround category method that makes iterator more generic.
func (i *categoryIterator) Ent() (interface{}, error) {
	return i.Category()
}

func (i *categoryIterator) Category() (*categoryEntity, error) {
	var ent categoryEntity
	cols, err := i.rows.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type categoryCriteria struct {
	offset, limit int64
	sort          map[string]bool
	content       *qtypes.String
	createdAt     *qtypes.Timestamp
	id            *qtypes.Int64
	name          *qtypes.String
	parentID      *qtypes.Int64
	updatedAt     *qtypes.Timestamp
}

func (c *categoryCriteria) WriteComposition(sel string, com *pqtgo.Composer, opt *pqtgo.CompositionOpts) (err error) {
	if _, err = com.WriteString(" WHERE "); err != nil {
		return
	}

	if c.content != nil && c.content.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	pqtgo.WriteCompositionQueryString(c.content, tableCategoryColumnContent, com, pqtgo.And)

	if c.createdAt != nil && c.createdAt.Valid {
		createdAtt1 := c.createdAt.Value()
		if createdAtt1 != nil {
			createdAt1, err := ptypes.Timestamp(createdAtt1)
			if err != nil {
				return err
			}
			switch c.createdAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				if c.createdAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnCreatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.createdAt.Value())
			case qtypes.QueryType_IN:
				if len(c.createdAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCategoryColumnCreatedAt)
					com.WriteString(" IN (")
					for i, v := range c.createdAt.Values {
						if i != 0 {
							com.WriteString(",")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				createdAtt2 := c.createdAt.Values[1]
				if createdAtt2 != nil {
					createdAt2, err := ptypes.Timestamp(createdAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCategoryColumnCreatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(createdAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCategoryColumnCreatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(createdAt2)
				}
			}
		}
	}

	if c.id != nil && c.id.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	if err = pqtgo.WriteCompositionQueryInt64(c.id, tableCategoryColumnID, com, pqtgo.And); err != nil {
		return
	}

	if c.name != nil && c.name.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	pqtgo.WriteCompositionQueryString(c.name, tableCategoryColumnName, com, pqtgo.And)

	if c.parentID != nil && c.parentID.Valid && com.Dirty {
		com.WriteString(" AND ")
		com.Dirty = false
	}
	if err = pqtgo.WriteCompositionQueryInt64(c.parentID, tableCategoryColumnParentID, com, pqtgo.And); err != nil {
		return
	}

	if c.updatedAt != nil && c.updatedAt.Valid {
		updatedAtt1 := c.updatedAt.Value()
		if updatedAtt1 != nil {
			updatedAt1, err := ptypes.Timestamp(updatedAtt1)
			if err != nil {
				return err
			}
			switch c.updatedAt.Type {
			case qtypes.QueryType_NULL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" IS NOT NULL ")
				} else {
					com.WriteString(" IS NULL ")
				}
			case qtypes.QueryType_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				if c.updatedAt.Negation {
					com.WriteString(" <> ")
				} else {
					com.WriteString(" = ")
				}
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(">")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_GREATER_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(">=")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(" < ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_LESS_EQUAL:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				com.WriteString(tableCategoryColumnUpdatedAt)
				com.WriteString(" <= ")
				com.WritePlaceholder()
				com.Add(c.updatedAt.Value())
			case qtypes.QueryType_IN:
				if len(c.updatedAt.Values) > 0 {
					if com.Dirty {
						com.WriteString(" AND ")
					}
					com.Dirty = true

					com.WriteString(tableCategoryColumnUpdatedAt)
					com.WriteString(" IN (")
					for i, v := range c.updatedAt.Values {
						if i != 0 {
							com.WriteString(",")
						}
						com.WritePlaceholder()
						com.Add(v)
					}
					com.WriteString(") ")
				}
			case qtypes.QueryType_BETWEEN:
				if com.Dirty {
					com.WriteString(" AND ")
				}
				com.Dirty = true

				updatedAtt2 := c.updatedAt.Values[1]
				if updatedAtt2 != nil {
					updatedAt2, err := ptypes.Timestamp(updatedAtt2)
					if err != nil {
						return err
					}
					com.WriteString(tableCategoryColumnUpdatedAt)
					com.WriteString(" > ")
					com.WritePlaceholder()
					com.Add(updatedAt1)
					com.WriteString(" AND ")
					com.WriteString(tableCategoryColumnUpdatedAt)
					com.WriteString(" < ")
					com.WritePlaceholder()
					com.Add(updatedAt2)
				}
			}
		}
	}

	if !com.Dirty {
		com.ResetBuf()
	}
	if c.offset > 0 {
		if _, err = com.WriteString(" OFFSET "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.offset)
	}
	if c.limit > 0 {
		if _, err = com.WriteString(" LIMIT "); err != nil {
			return
		}
		if err = com.WritePlaceholder(); err != nil {
			return
		}
		if _, err = com.WriteString(" "); err != nil {
			return
		}
		com.Add(c.limit)
	}
	com.Dirty = false

	return
}

type categoryPatch struct {
	content   *ntypes.String
	createdAt *time.Time
	name      *ntypes.String
	parentID  *ntypes.Int64
	updatedAt *time.Time
}

type categoryRepositoryBase struct {
	table   string
	columns []string
	db      *sql.DB
	dbg     bool
	log     log.Logger
}

func ScanCategoryRows(rows *sql.Rows) ([]*categoryEntity, error) {
	var (
		entities []*categoryEntity
		err      error
	)
	for rows.Next() {
		var ent categoryEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.Name,
			&ent.ParentID,
			&ent.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return entities, nil
}

func (r *categoryRepositoryBase) Count(c *categoryCriteria) (int64, error) {

	com := pqtgo.NewComposer(6)
	buf := bytes.NewBufferString("SELECT COUNT(*) FROM ")
	buf.WriteString(r.table)

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return 0, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Count"); err != nil {
			return 0, err
		}
	}

	var count int64
	if err := r.db.QueryRow(buf.String(), com.Args()...).Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *categoryRepositoryBase) Find(c *categoryCriteria) ([]*categoryEntity, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	return ScanCategoryRows(rows)
}
func (r *categoryRepositoryBase) FindIter(c *categoryCriteria) (*categoryIterator, error) {

	com := pqtgo.NewComposer(1)
	buf := bytes.NewBufferString("SELECT ")
	buf.WriteString(strings.Join(r.columns, ", "))
	buf.WriteString(" FROM ")
	buf.WriteString(r.table)
	buf.WriteString(" ")

	if err := c.WriteComposition("", com, pqtgo.And); err != nil {
		return nil, err
	}
	if com.Dirty {
		buf.WriteString(" WHERE ")
	}
	if com.Len() > 0 {
		buf.ReadFrom(com)
	}

	if r.dbg {
		if err := r.log.Log("msg", buf.String(), "function", "Find"); err != nil {
			return nil, err
		}
	}

	rows, err := r.db.Query(buf.String(), com.Args()...)
	if err != nil {
		return nil, err
	}

	return &categoryIterator{rows: rows}, nil
}
func (r *categoryRepositoryBase) FindOneByID(id int64) (*categoryEntity, error) {
	var (
		query  string
		entity categoryEntity
	)
	query = `SELECT content,
created_at,
id,
name,
parent_id,
updated_at
 FROM example.category WHERE id = $1`
	err := r.db.QueryRow(query, id).Scan(
		&entity.Content,
		&entity.CreatedAt,
		&entity.ID,
		&entity.Name,
		&entity.ParentID,
		&entity.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &entity, nil
}
func (r *categoryRepositoryBase) Insert(e *categoryEntity) (*categoryEntity, error) {
	insert := pqcomp.New(0, 6)
	insert.AddExpr(tableCategoryColumnContent, "", e.Content)
	insert.AddExpr(tableCategoryColumnCreatedAt, "", e.CreatedAt)
	insert.AddExpr(tableCategoryColumnName, "", e.Name)
	insert.AddExpr(tableCategoryColumnParentID, "", e.ParentID)
	insert.AddExpr(tableCategoryColumnUpdatedAt, "", e.UpdatedAt)

	b := bytes.NewBufferString("INSERT INTO " + r.table)

	if insert.Len() != 0 {
		b.WriteString(" (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.Key())
		}
		insert.Reset()
		b.WriteString(") VALUES (")
		for insert.Next() {
			if !insert.First() {
				b.WriteString(", ")
			}

			fmt.Fprintf(b, "%s", insert.PlaceHolder())
		}
		b.WriteString(")")
		if len(r.columns) > 0 {
			b.WriteString("RETURNING ")
			b.WriteString(strings.Join(r.columns, ","))
		}
	}

	err := r.db.QueryRow(b.String(), insert.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Name,
		&e.ParentID,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return e, nil
}
func (r *categoryRepositoryBase) UpdateOneByID(id int64, patch *categoryPatch) (*categoryEntity, error) {
	update := pqcomp.New(0, 6)
	update.AddExpr(tableCategoryColumnID, pqcomp.Equal, id)
	update.AddExpr(tableCategoryColumnContent, pqcomp.Equal, patch.content)
	if patch.createdAt != nil {
		update.AddExpr(tableCategoryColumnCreatedAt, pqcomp.Equal, patch.createdAt)

	}
	update.AddExpr(tableCategoryColumnName, pqcomp.Equal, patch.name)
	update.AddExpr(tableCategoryColumnParentID, pqcomp.Equal, patch.parentID)
	if patch.updatedAt != nil {
		update.AddExpr(tableCategoryColumnUpdatedAt, pqcomp.Equal, patch.updatedAt)
	} else {
		update.AddExpr(tableCategoryColumnUpdatedAt, pqcomp.Equal, "NOW()")
	}

	if update.Len() == 0 {
		return nil, errors.New("category update failure, nothing to update")
	}
	query := "UPDATE example.category SET "
	for update.Next() {
		if !update.First() {
			query += ", "
		}

		query += update.Key() + " " + update.Oper() + " " + update.PlaceHolder()
	}
	query += " WHERE id = $1 RETURNING " + strings.Join(r.columns, ", ")
	var e categoryEntity
	err := r.db.QueryRow(query, update.Args()...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Name,
		&e.ParentID,
		&e.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	return &e, nil
}
func (r *categoryRepositoryBase) DeleteOneByID(id int64) (int64, error) {
	query := "DELETE FROM example.category WHERE id = $1"

	res, err := r.db.Exec(query, id)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const SQL = `
-- do not modify, generated by pqt

CREATE SCHEMA IF NOT EXISTS example; 

CREATE TABLE IF NOT EXISTS example.news (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	lead TEXT,
	title TEXT NOT NULL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.news_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.news_title_key" UNIQUE (title)
);

CREATE TABLE IF NOT EXISTS example.comment (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	news_id BIGINT NOT NULL,
	news_title TEXT NOT NULL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.comment_news_id_fkey" FOREIGN KEY (news_id) REFERENCES example.news (id),
	CONSTRAINT "example.comment_news_title_fkey" FOREIGN KEY (news_title) REFERENCES example.news (title)
);

CREATE TABLE IF NOT EXISTS example.category (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	name TEXT NOT NULL,
	parent_id BIGINT,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.category_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.category_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES example.category (id)
);

`
